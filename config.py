'''  Формат, который мне очень нравится, поскольку
он расширяемый, заключается в использовании класса
для хранения переменных конфигурации. Чтобы все было
хорошо организовано, я собираюсь создать класс
конфигурации в отдельном модуле Python. Ниже вы
можете увидеть новый класс конфигурации для этого
 приложения, хранящийся в модуле config.py в каталоге верхнего(!!!) уровня.'''
import os
basedir = os.path.abspath(os.path.dirname(__file__))

# класс параметров конфигурации для приложения
class Config(object):
    SECRET_KEY  = os.environ.get('SECRET_KEY') or 'you-will-never-guess'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    ''' SECRET_KEY, Flask и некоторые его расширения используют значение секретного ключа в
        качестве криптографического ключа, полезного для генерации подписей или токенов.
        Расширение Flask-WTF использует его для защиты веб-форм от противной атаки под
        названием Cross-Site Request Forgery или CSRF (произносится как «seasurf»).
            Значение секретного ключа задается как выражение с двумя терминами, к которым
        присоединяется оператор OR. Первый термин ищет значение переменной среды,
        также называемой SECRET_KEY. Второй термин, это просто жестко закодированная строка. 
        Идея в том, что значение, появляющееся из переменной среды, предпочтительнее,
        но если среда не определяет переменную, то вместо нее используется жестко 
        закодированная строка'''
    '''Расширение Flask-SQLAlchemy принимает местоположение базы данных приложения из
     переменной конфигурации SQLALCHEMY_DATABASE_URI'''
